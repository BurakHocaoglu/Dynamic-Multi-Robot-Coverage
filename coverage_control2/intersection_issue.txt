#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <CGAL/Polygon_with_holes_2.h>
#include <CGAL/draw_polygon_2.h>
#include <CGAL/draw_polygon_with_holes_2.h>
#include <CGAL/Boolean_set_operations_2.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel EK;

typedef CGAL::Polygon_with_holes_2<EK>                       Polygon_with_holes_2;
typedef CGAL::Polygon_2<EK>                                  Polygon_2;
typedef CGAL::Point_2<EK>                                    Point;

int main() {
  Point agent(0., 50.);

  Polygon_2 outer_polygon;
  outer_polygon.push_back(Point(80., 80.)); outer_polygon.push_back(Point(80., -80.));
  outer_polygon.push_back(Point(-80., -80.)); outer_polygon.push_back(Point(-80., 80.));

  std::vector<Polygon_2> holes(4);
  holes[0].push_back(Point(-60., -20.)); holes[0].push_back(Point(-20., -20.));
  holes[0].push_back(Point(-20., -60.)); holes[0].push_back(Point(-60., -60.));

  holes[1].push_back(Point(-60., 60.)); holes[1].push_back(Point(-20., 60.));
  holes[1].push_back(Point(-20., 20.)); holes[1].push_back(Point(-60., 20.));

  holes[2].push_back(Point(20., 60.)); holes[2].push_back(Point(60., 60.));
  holes[2].push_back(Point(60., 20.)); holes[2].push_back(Point(20., 20.));

  holes[3].push_back(Point(20., -20.)); holes[3].push_back(Point(60., -20.));
  holes[3].push_back(Point(60., -60.)); holes[3].push_back(Point(20., -60.));

  Polygon_with_holes_2 p(outer_polygon, holes.begin(), holes.end());

  CGAL::draw(p);

  for (size_t i = 0; i < 7; i++) {
    std::cout << "Step: " << i + 1 << std::endl;

    Polygon_2 cvx_cell;
    cvx_cell.push_back(Point(CGAL::to_double(agent.x()) - 15., CGAL::to_double(agent.y()) + 15.));
    cvx_cell.push_back(Point(CGAL::to_double(agent.x()) - 15., CGAL::to_double(agent.y()) - 15.));
    cvx_cell.push_back(Point(CGAL::to_double(agent.x()) + 15., CGAL::to_double(agent.y()) - 15.));
    cvx_cell.push_back(Point(CGAL::to_double(agent.x()) + 15., CGAL::to_double(agent.y()) + 15.));

    std::list<Polygon_with_holes_2> intersection_pieces;
    CGAL::intersection(p, cvx_cell, std::back_inserter(intersection_pieces));

    int n_pieces = intersection_pieces.size();

    if (n_pieces == 0) 
      std::cout << "No intersection!\n";
    else if (n_pieces > 1) {
      std::cout << "Multiple intersections!\n";
      auto itr = intersection_pieces.begin();
      for (; itr != intersection_pieces.end(); itr++)
        CGAL::draw(*itr);
    } else {
      std::cout << "Single intersection!\n";
      if (intersection_pieces.front().outer_boundary().is_clockwise_oriented()) {
        std::cout << "Clockwise\n";
      } else {
        std::cout << "Counter-Clockwise\n";
        intersection_pieces.front().outer_boundary().reverse_orientation();
      }
      CGAL::draw(intersection_pieces.front());
    }

    agent = Point(CGAL::to_double(agent.x()) + 5., CGAL::to_double(agent.y()) + 5.);
  }

  return EXIT_SUCCESS;
}
